
"""
This script is to be used with MUSE data.

It uses an object position catalog and a MUSE datacube to perform extended
faint source detection on objects labelled lyman-alpha emitters. It aims at
detecting Lyman-alpha haloes eventually present in their vicinity.

:author: Jean-Baptiste Courbot - jean-baptiste.courbot@univ-lyon1.fr
:date: november 18, 2015

"""


import matplotlib.pyplot as plt
from astropy.io import fits
import numpy as np
import sys
import time
import numpy.ma as ma
import scipy.ndimage.morphology as morph
sys.path.insert(0,'../lib')
import detection_preprocessing as nbp
import strategy_detection_pose as sd
import mle_sparse_est as mse
from astropy.table import Table
import scipy.signal as si
import scipy.stats as st

from matplotlib.backends.backend_pdf import PdfPages



""" Notes pour l'installation de MPDAF : 
    - Il faut installer la librairie C cfitsio,
    - Astropy en v 1.x, a telecharger
    """
sys.path.insert(0,'../MPDAF')
#from mpdaf.obj import Cube
from mpdaf.obj import WCS
from mpdaf.obj import WaveCoord
from mpdaf.obj import Image
from mpdaf.obj import Spectrum


from mpdaf.sdetect import Source


def extraire_cube(cube, coords_lya,S,W,marge_cube ):
    """
    Extract a subcube around the provided coordinates.
    
    :param ndarray cube: full datacube in which extraction is performed.
    :param ndarray coords_lya: list of coordinates.
    :param int S: spatial size of the subcube to extract.
    :param int W: spectral length of the subcube to extract.
    :param int marge_cube: margin to ignore in the total datacube.
     
    """
    xmin = coords_lya[0]-S/2 ; xmax = coords_lya[0]+S/2
    ymin = coords_lya[1]-S/2 ; ymax = coords_lya[1]+S/2
    lmin = coords_lya[2]-W/2 ; lmax = coords_lya[2]+W/2
    
    marge_cube = 0
    while xmin < marge_cube or ymin<marge_cube or xmax>cube.shape[2]-marge_cube or ymax>cube.shape[1]-marge_cube:
        S = S-2
        xmin = coords_lya[0]-S/2 ; xmax = coords_lya[0]+S/2
        ymin = coords_lya[1]-S/2 ; ymax = coords_lya[1]+S/2
    
    while lmin < marge_cube  or lmax>cube.shape[0]:
        W = W - 2
        lmin = coords_lya[2]-W/2 ; lmax = coords_lya[2]+W/2
    
    s_new = S

    centre = np.array([int(s_new/2), int(s_new/2)])

    sous_cube = cube[lmin:lmax,ymin:ymax,xmin:xmax]
    
    sous_cube[np.isnan(sous_cube)]=0
    
    sous_cube = np.swapaxes(sous_cube,2,0)
    
    return sous_cube,centre,s_new,xmin,xmax,ymin,ymax,lmin,lmax

def calcul_fwhm(lam):
    """
    Full-Width at Half Maximum computation for the HDFS datacube.
    See Bacon et al., 2015, *The MUSE 3D View of the Hubble Deep Field South*.
    
    :param float lam: wavelength to perform the computation.
    
    """
    return -1.625*10**(-4) *lam + 4.5375



if __name__=='__main__':
    # Useful parameters
    lambda_0 = 4750    # see Bacon et al, 2015
    lambda_lya = 1216
    pas_spectral = 1.25 # Angstrom / spectral band
    
    
    marge_cube = 0
    beta=2.6
    pas = 0.15
    nb_ech_dic = 50
    
    taille_f = 11
    
    marge = int(taille_f/2)
    W=20
    D = nbp.gen_dic(W, pas = pas, nb_ech=nb_ech_dic,asym=0)
    
    wcs1 = WCS(crval=0,cdelt=0.2)
    wave1 = WaveCoord(cdelt=1.25, crval=4750.0, cunit='Angstrom')
    
    colmap = plt.cm.Blues
    
    # Object catalog loading
    f = fits.open('../data/Catalog_HDFS_v1p0.fits',memmap=True)
    
    # Cube loading
    hdulist = fits.open('../data/DATACUBE-HDFS-v1.24.fits',memmap=True)
    cube =  hdulist['data'].data
    
    #%% Lyman-alpha lines info for the HDFS cube:
    #LAMBDA_LINES=np.load('./data/lambda_line.npy')
    LAMBDA_LINES = {
    43: {'lambda':[5212., 5230.],'fwhm':0.74},
    92: {'lambda':[6778., 6800.],'fwhm':0.675},
    95: {'lambda':[6344., 6359.],'fwhm':0.695},
    112: {'lambda':[5963., 5975.],'fwhm':0.72},
    139: {'lambda':[5275., 5297.],'fwhm':0.73},
    159: {'lambda':[5764., 5775.],'fwhm':0.725},
    162: {'lambda':[5196., 5213.],'fwhm':0.74},
    181: {'lambda':[5269., 5280.],'fwhm':0.735},
    200: {'lambda':[5285., 5294.],'fwhm':0.735},
    216: {'lambda':[6092., 6115.],'fwhm':0.71},
    232: {'lambda':[7553, 7564],'fwhm':0.645},
    246: {'lambda':[8116., 8132.],'fwhm':0.635},
    257: {'lambda':[6715., 6726.],'fwhm':0.725},
    290: {'lambda':[8611., 8623.],'fwhm':0.62},
    294: {'lambda':[6067., 6078.],'fwhm':0.71},
    308: {'lambda':[6096., 6111.],'fwhm':0.71},
    311: {'lambda':[5941., 5951.],'fwhm':0.72},
    324: {'lambda':[5471., 5479.],'fwhm':0.73},
    325: {'lambda':[6927., 6940.],'fwhm':0.665},
    334: {'lambda':[7188., 7198.],'fwhm':0.66},
    338: {'lambda':[7170., 7181.],'fwhm':0.66},
    393: {'lambda':[6305., 6316.],'fwhm':0.695},
    422: {'lambda':[5016., 5025.],'fwhm':0.75},
    430: {'lambda':[8849., 8862.],'fwhm':0.61},
    437: {'lambda':[5005., 5015.],'fwhm':0.75},
    449: {'lambda':[5196., 5205.],'fwhm':0.74},
    469: {'lambda':[5427., 5437.],'fwhm':0.73},
    484: {'lambda':[7185., 7196.],'fwhm':0.66},
    489: {'lambda':[4806., 4819.],'fwhm':0.76},
    500: {'lambda':[5470., 5480.],'fwhm':0.73},
    503: {'lambda':[5284., 5295.],'fwhm':0.73},
    514: {'lambda':[5861., 5873.],'fwhm':0.725},
    520: {'lambda':[5441., 5451.],'fwhm':0.73},
    543: {'lambda':[5628., 5639.],'fwhm':0.725},
    546: {'lambda':[8157., 8174.],'fwhm':0.635},
    547: {'lambda':[8157., 8170.],'fwhm':0.635},
    549: {'lambda':[6895., 6905.],'fwhm':0.665},
    551: {'lambda':[5079., 5089.],'fwhm':0.75},
    553: {'lambda':[7388., 7401.],'fwhm':0.655},
    558: {'lambda':[5015., 5025.],'fwhm':0.75},
    563: {'lambda':[5865., 5876.],'fwhm':0.725},
    568: {'lambda':[6880., 6894.],'fwhm':0.67},
    574: {'lambda':[8158., 8168.],'fwhm':0.635},
    579: {'lambda':[5595., 5604.],'fwhm':0.68},
    580: {'lambda':[5631., 5640.],'fwhm':0.725},
    583: {'lambda':[7187., 7195.],'fwhm':0.66},
    56: {'lambda':[4871., 4890.],'fwhm':0.76},
    40: {'lambda':[4872., 4887.],'fwhm':0.76},
    71: {'lambda': [4961.6, 4973.7],'fwhm':0.76},
    89: {'lambda': [6089.5, 6110.2],'fwhm':0.76},
    119: {'lambda': [4992.0, 4999],'fwhm':0.76},
    121: {'lambda': [5474.1, 5480.5],'fwhm':0.76},
    144: {'lambda': [6092, 6110.0],'fwhm':0.71},
    146: {'lambda': [5826, 5837],'fwhm':0.72},
    155: {'lambda': [4883.0, 4888.0],'fwhm':0.76},
    183: {'lambda': [5314.6, 5325.2],'fwhm':0.73},
    186: {'lambda': [7170.0, 7185],'fwhm':0.66},
    202: {'lambda': [5197., 5209.4],'fwhm':0.73},
    218: {'lambda': [7169.1, 7183.2],'fwhm':0.66},
    225: {'lambda': [6454.4, 6466.3],'fwhm':0.695},
    238: {'lambda': [5860.1, 5861.8],'fwhm':0.72},
    261: {'lambda': [5314.4, 5325.0],'fwhm':0.76},
    271: {'lambda': [6308.0, 6318.],'fwhm':0.695},
    363: {'lambda': [6717.0, 6730.5],'fwhm':0.725},
    386: {'lambda': [5761.9, 5769.2],'fwhm':0.72},
    433: {'lambda': [5431.1, 5440.0],'fwhm':0.76},
    441: {'lambda': [6919.5, 6933.1],'fwhm':0.665},
    452: {'lambda': [5005.6, 5015.7],'fwhm':0.75},
    453: {'lambda': [6930.0, 6939.8],'fwhm':0.665},
    462: {'lambda': [8016., 8026.],'fwhm':0.64},
    474: {'lambda': [6937.3, 6956.1],'fwhm':0.665},
    478: {'lambda': [5429.9, 5440.0],'fwhm':0.76},
    492: {'lambda': [8216.0, 8228.1],'fwhm':0.635},
    498: {'lambda': [6326.0, 6338.5],'fwhm':0.695},
    499: {'lambda': [6921., 6934.4],'fwhm':0.665},
    501: {'lambda': [5014.0, 5026.2],'fwhm':0.75},
    513: {'lambda': [5198, 5209],'fwhm':0.74},
    534: {'lambda': [6599.0, 6615],'fwhm':0.7},
    548: {'lambda': [6914, 6923],'fwhm':0.665},
    550: {'lambda': [6882, 6890.3],'fwhm':0.665},
    552: {'lambda': [7392, 7402.1],'fwhm':0.66},
    555: {'lambda': [6693, 6709],'fwhm':0.665},
    557: {'lambda': [7539., 7550.0],'fwhm':0.645},
    559: {'lambda': [7152.6, 7159.6],'fwhm':0.66},
    560: {'lambda': [8359.6, 8370.0],'fwhm':0.64},
    561: {'lambda': [7060.2, 7072.8],'fwhm':0.66},
    562: {'lambda': [7101.0, 7110.2],'fwhm':0.66},
    564: {'lambda': [8607.3, 8622.0],'fwhm':0.62},
    573: {'lambda': [8838.2, 8848.6],'fwhm':0.62},
    575: {'lambda': [8673., 8684.],'fwhm':0.62},
    577: {'lambda': [8215.6, 8228.3],'fwhm':0.62},
    578: {'lambda': [5078.7, 5088.3],'fwhm':0.75},
    581: {'lambda': [5860., 5879.],'fwhm':0.72},
    582: {'lambda': [6797.8, 6808.8],'fwhm':0.725},
    584: {'lambda': [8377, 8389],'fwhm':0.64},
    585: {'lambda': [5271.9, 5280.2],'fwhm':0.74},
    586: {'lambda': [7414, 7428],'fwhm':0.66},
    587: {'lambda': [6606.7, 6616.0],'fwhm':0.665},
    }
    
    #%% Let us get the X,Y,Lambda coordinates (+ Dec,Ra)
    tbdata = f[1].data
    z = tbdata['Z']
    tout = tbdata
    coords = np.array([tout['X'], tout['Y'], tout['Z']])
    
    num = tout['ID']
    categ = tout['CATEGORY']
    
    # Now we keep only lyman-alpha emitters, labeled as 'Lya' in the catalog
    cat_lya = tout[(categ=='Lya')&(z>=0)]
    coords_lya = np.array([cat_lya['X'], cat_lya['Y'], cat_lya['Z']])
    
    ra_lya = cat_lya['RA']
    dec_lya = cat_lya['DEC']
    z_lya = cat_lya['Z']
    
    coords_lya[2,:] = ((1 + coords_lya[2,:])*lambda_lya - lambda_0)/pas_spectral
    
    coords_lya = np.round(coords_lya)
    num_lya = num[(categ=='Lya')&(z>=0)]
    

    
    liste_mauvais = np.zeros(shape=(num_lya.shape))
    liste_mauvais[69]=1;

    PFA = np.array([0.1,0.01,0.001, 0.0001])
    
    
    nb_obj = num_lya.shape[0]
    nb_col = 3
    NB = 3


    
    ## Parameters for plotting
    W = 20
    W_aff = 2*W
    start = time.time()
    nb_li = 3
    nb_col = 3
    num_plot=1
    
    
    # Method parameters
    pfa_faint=0.0001
    pfa_bright=0.01
    diag = 1
    P = 1
    
    # Processing options:
    type_test='full' # ['full', 'sample']
    
    version = '1.3'
    
    nom_dossier = '../results/HDFS_1.24_'+type_test+' ('+version+')/'
    
    doc_pdf = PdfPages(nom_dossier+'2015-11-Lya-ext-HDFS-'+type_test+'-1.24.pdf')
    
    if type_test =='sample':
        iterobj = (0,1,4,5,7,24,29,39)
    else:
        iterobj = range(nb_obj)
    
    #%%
    
    for obj in iterobj:
    
        if liste_mauvais[obj]==0:
            # Current FWHM
            fwhm_courant = calcul_fwhm(lam=coords_lya[2,obj]*pas_spectral + lambda_0)
            
            # For display purpose
            F = nbp.Moffat(taille_f, fwhm_courant,beta)
            
            W_aff = 300
            Fig = plt.figure(figsize=(nb_col*4.5,4*nb_li))
            print 'Num. '+ str(num_lya[obj]) + ', z = ' + str(z_lya[obj])
            
            if num_lya[obj] in (40,489):
                S = 100 + 2*marge
            elif num_lya[obj] in (139,):
                S = 80 + 2*marge
        
            elif num_lya[obj] in (43,):
                S = 50 + 2*marge
                
            elif num_lya[obj] in (139,257,294,308,311,334,363,430,449,469,474,489,500,514,546,552,568,577,580,581):
                S = 60+2*marge
        
            else:
                S = 40 + 2*marge
                
            Y_src, centre,s_new, xmin,xmax,ymin,ymax,lmin,lmax = extraire_cube(cube, coords_lya[:,obj],S,W_aff,marge_cube )
            
            # Median filtering. 
            ss_cube_medfilt = si.medfilt(Y_src,(1,1,301))
            Y_ms = Y_src - ss_cube_medfilt
            
            pos_ligne = int(Y_ms.shape[2]/2)
            Y_ms = Y_ms[:,:,pos_ligne-0.5*W:pos_ligne+0.5*W]
            
        
            # Actual detection
            res, val, ests, X_init, val_init = sd.detection_strategy(np.tile(Y_ms[:,:,:,np.newaxis],(1,1,1,2)), P, diag, pfa_bright, pfa_faint, fwhm_courant, taille_f, beta)
        
            ind_2d = ests
            init = X_init
         
            # Thresholds for the provided false alarm probability.
            ksi = st.chi2.isf(PFA, df=X_init.sum())
            
            
            
            #------- Spectra retrieving ----#
            while W_aff/2 > coords_lya[2,obj]-lmin:
                W_aff -=2
        
            Y_aff = cube[ coords_lya[2,obj]-W_aff/2: coords_lya[2,obj]+W_aff/2,ymin:ymax,xmin:xmax]
            Y_aff = np.swapaxes(Y_aff,2,0)
            
            # Initial detection region
            reg_init = ma.masked_array(Y_aff, np.tile(np.invert(init)[:,:,np.newaxis], (1,1,W_aff)))
            sp_init = ma.mean(ma.mean(reg_init, axis=0), axis=0)
            
            # Outer detected region, connex to the center
            ma_ext = morph.binary_propagation(init, mask = res)
            reg_ext = ma.masked_array(Y_aff, np.tile(np.invert(ma_ext)[:,:,np.newaxis], (1,1,W_aff)))
            sp_ext = ma.mean(ma.mean(reg_ext, axis=0), axis=0)
            
            ma_tout = (res+init)>0
            # Outer detected regions, non-connex to the center
            ma_ext_pani = (res*(ma_ext==0)>0)
            reg_ext_pani = ma.masked_array(Y_aff, np.tile(np.invert(ma_ext_pani)[:,:,np.newaxis], (1,1,W_aff)))
            sp_ext_pani = ma.mean(ma.mean(reg_ext_pani, axis=0), axis=0)
            
            # Outside 
            reg_reste = ma.masked_array(Y_aff, np.tile(ma_ext[:,:,np.newaxis], (1,1,W_aff)))
            sp_reste = ma.mean(ma.mean(reg_reste, axis=0), axis=0)
            sp_reste_ex = Y_aff[-1,0,:]
        
            pos_sp = np.arange( coords_lya[2,obj]-W_aff/2, coords_lya[2,obj]+W_aff/2)*pas_spectral + lambda_0
            
            bruit_tab = np.reshape(reg_reste,(reg_reste.shape[0]**2,reg_reste.shape[2]))
            sigma_bruit = np.ma.cov(bruit_tab,rowvar=0)
        
            rsb = 10.*np.log10((np.linalg.norm(sp_ext)**2)/np.trace(sigma_bruit))
        
        
            amax =2 * sp_ext.max()
            amin = 0
            #------- Moments retrieving ----#
        
            im_ind_est,im_weight_est = mse.get_sparse_estimate(Y_ms,F,D)
        
            flux,position,largeur = mse.get_moments(im_ind_est,im_weight_est,D,W,pas,pas_spectral)
            # normalizing flux
            flux *= Y_ms[centre[0]+marge,centre[1]+marge,:].sum()/flux[centre[0],centre[1]]    
        
            # Adjusting positions
            position = lambda_0+(coords_lya[2,obj]-W/2 + position )*pas_spectral
            #--------------------------------------#
            #-------Results retrievings------------#
            #----------(MPDAF Objects)-------------#
            # 0) Useful data

            li = LAMBDA_LINES[num_lya[obj]]['lambda']
            
            arr = {'lambda': np.array([LAMBDA_LINES[num_lya[obj]]['lambda']]),
                    'fwhm': [LAMBDA_LINES[num_lya[obj]]['fwhm']]}
            line=Table(arr, names=('lambda',  'fwhm'))  
            
            li_cube = np.round((np.array(li)-lambda_0)/pas_spectral - lmin)
            # 1) Images (binary + statistics)
            im_wh = Image(wcs=wcs1, data=Y_src.mean(axis=2).T)
            im_nb = Image(wcs=wcs1, data=Y_src[:,:,li_cube[0]:li_cube[1]].mean(axis=2).T)
            im_det_cont = Image(wcs=wcs1, data=val.T)
            im_det = Image(wcs=wcs1, data=(res.T-init.T)>0)
            im_det_gal = Image(wcs=wcs1, data=init.T)
            im_det_all = Image(wcs=wcs1, data=((res.T+init.T)>0))
            
            # 1b) Moments
            im_flux = Image(wcs=wcs1, data=ma.filled(flux.T,np.nan))
            im_position = Image(wcs=wcs1, data=ma.filled(position.T,np.nan))
            im_largeur = Image(wcs=wcs1, data=ma.filled(largeur.T,np.nan))
            
            dic_images = {'MUSE_WHITE':im_wh, 'MUSE_NB':im_nb, 'DET_STAT':im_det_cont,'DET_BIN_ALL':im_det_all, 'DET_BIN_HAL':im_det,'DET_BIN_GAL':im_det_gal,'FLUX':im_flux, 'POSITION':im_position, 'FWHM':im_largeur}
            
            # 2) Detection spectra
            waveloc = WaveCoord(cdelt=1.25, crval=lambda_0 + (coords_lya[2,obj]-W_aff/2)*pas_spectral, cunit='Angstrom')
            spe_centre = Spectrum(data=sp_init,wave=waveloc)
            spe_ext = Spectrum(data=sp_ext,wave=waveloc)
            spe_ext_pani = Spectrum(data=sp_ext_pani,wave=waveloc)
            spe_reste= Spectrum(data=sp_reste,wave=waveloc)  
            spe_reste_ex= Spectrum(data=sp_reste_ex,wave=waveloc)  
            
            dic_spectres = {'CENTER':spe_centre, 'PERIPH_ADJ':spe_ext,'PERIPH_NOADJ':spe_ext_pani, 'EXT':spe_reste, 'EXTEX':spe_reste_ex}# 'MUSE_NB':im_nb, 'DET_CONT':im_det_cont, 'DET':im_det}
            
        
            objet=Source.from_data(ID=num_lya[obj],lines=line,ra=ra_lya[obj],dec=dec_lya[obj],origin=('HEOLHT', version, 'HDFS-1.24'), images=dic_images, spectra=dic_spectres)
            objet.add_comment(comment='Flux, largeur et position sont indicatifs',author='JBC')
            objet.fwhm_pix= (fwhm_courant,'FWHM_PIX')
            objet.im_size = (s_new,'IM_SIZE')
            objet.snr_est = (rsb,'SNR_EST')
            objet.im_margin = (marge,'IM_MARGIN')
            objet.write(nom_dossier+'ID'+str(num_lya[obj])+'.fits')
        
            #-------------------------------------#
            #-------- Display   ------------------#
            #-------------------------------------#
            # Text box
            props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
            texte = 'ID #%d \n $z = %.2f$ \n $\\hat{\mathrm{SNR}} =%.2f \mathrm{dB}$ '%(num_lya[obj], z_lya[obj], rsb )#' +str(num_lya[obj])+ ' \n z = '+ str(z_lya[obj]) + '\n SNR = '+str(rsb)+'dB'
            plt.suptitle(texte, bbox=props,fontsize=14)
        
            # 1st image: white image + catalog sources in the projected neighborhood
            ax1 = Fig.add_subplot(nb_li,nb_col, 1)
        
            ## All sources :
            plt.scatter(coords[0,:]-xmin, coords[1,:]-ymin, s=150, c='b');
            ## All sources with a close redshift (+/- 0.1)
            indices = np.abs(coords[2,:] - coords[2,num_lya[obj]])<0.1
            plt.scatter(coords[0,indices]-xmin, coords[1,indices]-ymin, s=300, c='r');
            objet.show_ima(ax1, 'MUSE_WHITE',cuts=(amin, amax))
        
            plt.axis('on')
            plt.title('Image blanche')
            plt.xlim([0,s_new]); plt.ylim([0,s_new])
            #-------------------------------------#
            # Second image : NB image + detection contours
            ax2 = Fig.add_subplot(nb_li,nb_col, 2)
            objet.show_ima(ax2, 'MUSE_NB',cuts=(amin, amax))
            ax2.axis('on')
            plt.contour((res+init>0).T, 1,colors='#760000')
            plt.contour((init).T, 1,colors='r',linestyle='dashed')
            plt.title('NB, Detection gal. ($P_\mathrm{FA}=10^{-2}$) et halo ($\mathrm{max}(P_\mathrm{FA})=10^{-4}$)')
        
            #-------------------------------------#
            # 3rd image : statistic map and detection contour for various PFA.
            ax3 = Fig.add_subplot(nb_li,nb_col, 3)
            val_aff_max = ma.masked_array(val,init!=1).min()
            plt.imshow(val.T, origin='lower',vmin=0,vmax=val_aff_max,cmap=colmap,interpolation='nearest')
            plt.contour(val.T, ksi)
            plt.title('Stat. et niveau ($10^{-4}\\leq \mathrm{max}(P_{FA}) \\leq 10^{-1}$)')
            ax3.axis('on')
            #-------------------------------------#
            # 4th image (second line) : spectra
            ax45 = Fig.add_subplot(nb_li,nb_col, (4,5))
            plt.title('Spectres par region')
            ax45.axis('on')

            objet.show_spec(ax45, 'CENTER',label='Centre')
            objet.show_spec(ax45, 'PERIPH_ADJ',label='Etendu connexe')
            objet.show_spec(ax45, 'PERIPH_NOADJ',label='E. non connexe')
            objet.show_spec(ax45, 'EXT',label='Exterieur')
            plt.xlim(pos_sp.min(),pos_sp.max())
            plt.legend()
            #-------------------------------------#
            # 5th image : FWHM of the FSF
            ax6 = Fig.add_subplot(nb_li,nb_col,6)
        
            F1 = nbp.Moffat(s_new+1, 0.75*5,beta)
            plt.imshow(F1, interpolation = 'Nearest',vmin=0, cmap = plt.cm.gray_r,origin='lower') ; 
            plt.title('FSF et sa FWHM pour $\\lambda_0$') ; 
            circle1=plt.Circle((int(s_new/2),int(s_new/2)),fwhm_courant,color='r',fill=False)
            ax6.add_artist(circle1)
                        
            #-------- Moments -------------#
            ## Displayed on the 6th, 7th and 8th image, last line.
            ax7 = Fig.add_subplot(nb_li,nb_col, 7)
            detec= (res+init>0)
            detec = detec[marge:S-marge,marge:S-marge]
            plt.xlabel('q (pixel)'); plt.ylabel('p (pixel)')
            plt.imshow(flux.T,interpolation= 'nearest', vmin = 0, cmap=plt.cm.gray_r,origin='lower')
            plt.title(' Flux estime')
            ax7.axis('on')
            plt.colorbar(fraction=0.046, pad=0.04)
            plt.contour(detec.T, 1,linewidths=2,colors='#760000')
            
            ax8 = Fig.add_subplot(nb_li,nb_col, 8)
            plt.imshow(position.T, interpolation= 'nearest',cmap=plt.cm.Spectral,origin='lower')
            plt.xlabel('q (pixel)'); plt.ylabel('p (pixel)')
            plt.colorbar(fraction=0.046, pad=0.04)
            plt.title('Position estimee')
            ax8.axis('on')
            plt.contour(detec.T, 1,linewidths=2,colors='w')
        
            ax9 = Fig.add_subplot(nb_li,nb_col, 9)
            objet.show_ima(ax9, 'FWHM',cmap=plt.cm.jet)
            plt.imshow(largeur.T, interpolation = 'nearest',cmap=plt.cm.coolwarm,origin='lower')
            plt.xlabel('q (pixel)'); plt.ylabel('p (pixel)')
            plt.colorbar(fraction=0.046, pad=0.04)
            plt.title('FWHM estimee')
            ax9.axis('on')
            plt.tight_layout()
            plt.contour(detec.T, 1,linewidths=2,colors='w')
        
            plt.subplots_adjust(top=0.85)

            num_plot +=1
            doc_pdf.savefig(Fig)
            plt.close(Fig)
            
          
    end = time.time()
    print str(end-start) + ' secondes, ' + str(num_plot-1) +' objets'
    print str((end-start)/(num_plot-1)) + ' secondes par objet'
    doc_pdf.close()
